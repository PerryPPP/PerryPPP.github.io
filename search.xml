<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[生活小记——在PKUSZ读PhD的第一年01]]></title>
    <url>%2F2019%2F09%2F03%2F%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94%E5%9C%A8PKUSZ%E8%AF%BBPhD%E7%9A%84%E7%AC%AC%E4%B8%80%E5%B9%B401%2F</url>
    <content type="text"><![CDATA[生活小记——在PKUSZ读PhD的第一年01My first year in Peking University Shenzhen，as a PhD student​ 入学已经一个星期了，昨天刚刚进入实验室，和师兄师姐们都还不熟悉。作为社交技能树完全没点亮的本人，稍微地感觉有点跟大家搭不上话QAQ。19级的新同学也并没怎么认识。但总的来说，新学校新环境并没有让我觉得有多不适应，大概是因为在广州呆了一段时间的缘故吧0.0 南燕很美，最美是雨天。雨水滴在树叶上，有一种独特的，潮湿的，南国特有的美感。我喜欢冬天白茫茫的雪，所以高中毕业我 ​ 昨天晚上，在Pkusz第一次失眠了，突然深刻地意识到PhD似乎真的是一个很特别的存在，尤其是本科起点的PhD。科研素养还没有培养好，工作的经验都来自于本科期间混的几个科研实习。但本科的科研实习没有成果压力，当时仅仅抱着学习新知识的心情就能够很开心地从早学到晚了0.0！而现在，摆在面前的踏踏实实是需要发表才能毕业的三篇期刊，心里的感觉还是很不一样的。就像是今天看的文章里说的“The jump from problem sets to research can be hard. ”。标准答案这个在我的人生中扎根了二十多年的东西，突然地就消失弱化了，就像一棵遮挡着我头顶天空的参天大树，突然落叶、枯萎，最终变成了空气中细细的尘埃。它还在我的身边，但不再陪伴我了。我的任务从学习变成了探索和研究。我的面前是大片大片的虚空和一个很大的裂缝，我须得跳过去，才能看到前面的风光景色。若我跃不过去，我必碌碌无为，囿于俗务烦恼，受制于毕业要求。这样的情形，品不出好坏，只理所当然的感到恐惧、迷茫、不知所措。很感谢陆师兄在昨天那个难熬的深夜，跟我讲了很多话，有指导，有经验，有鼓励和肯定，也有他自己的座右铭。“物来顺应，未来不迎，当时不杂，既过不恋。”最能提点我现在情形的一小句，就是这四个字“未来不迎”了，我不能因为一些看得见摸不到的困难过早地陷入焦虑不安的情绪。也许在读PhD的过程里我会遇到困难，但我不能因为可能会出现的困难而焦虑从而浪费掉宝贵的也许能够帮我规避困难的学习时光。 ​ 我还记得上次座谈会的时候，朱老师讲起实验组的博士大师姐时自豪的神情，“她什么时间也没耽误，二十五岁念完了两个PhD，去了上海，生了小孩，现在还当上了副教授。她——就是这样一个人，什么事也不愿意耽误。”当老师说到师姐是北京邮电大学毕业的时候，我突然地就回忆起，在准备保研时，我曾经看过一个论坛帖，是一个北邮的师姐写给学弟学妹们的安利贴，她说欢迎大家来PKUSZ，她的导师朱老师是一个很好很好的导师。现在看来这个学姐一定就是令老师骄傲的大师姐了。如果没有那个帖子，我也不会给朱老师写邮件，也许就没有这一段师生缘分了。所以说人这一辈子，缘分真的是一件很奇妙很奇妙的事情。世界上这么这么多人，大部分这辈子连擦肩的机会也无，而有的人，则在命中有着一场注定的相遇。 ​ 今天去实验室时，心情好多了。感觉自己畏惧环境时，环境就愈发令人害怕；而只要心里对环境的抵触没有了，环境与你的隔阂也不见了。今天是正式开始安排学习计划的第一天，给自己这一周定了满满的小任务，希望自己能够尽量好的去完成，也希望自己能够尽快融入进PhD这个新的人生角色当中。今天听了How to make a positive start to your PhD的网络讲座，感觉收获不少，明天开始复习数学知识和整理要看的paper了&gt; &lt;希望明天也能是像今天一样波澜不惊的一天吧。 ​ 思绪很乱，多年也不曾提笔写过什么文章了。只在这里做一个心情记录，希望自己回首时能记得最初的这种感觉。文章的结尾还是陆师兄之前赠我的一句话，我很喜欢。 ​ “曾经以为上升是像雄鹰一样腾空而起，面前的一切障碍不过是小丘小壑，现在反省过来，上升其实是爬楼梯，面前这个坎过不去，我就看不见未来。” ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛学习笔记2]]></title>
    <url>%2F2018%2F08%2F25%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[算法竞赛入门经典学习笔记02]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Priceton Alg Part I学习笔记01]]></title>
    <url>%2F2018%2F08%2F23%2FPriceton-Alg%2F</url>
    <content type="text"><![CDATA[Priceton Alg Part I学习笔记01Topics include union−find, binary search, stacks, queues, bags, insertion sort, selection sort, shellsort, quicksort, 3-way quicksort, mergesort, heapsort, binary heaps, binary search trees, red−black trees, separate-chaining and linear-probing hash tables, Graham scan, and kd-trees. Week 01]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典学习笔记1]]></title>
    <url>%2F2018%2F08%2F23%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[算法竞赛入门经典学习笔记01程序设计入门（顺序、分支、循环）printf 格式控制的总结：printf 格式控制的完整格式为： **%[-][0][m.n][l或h][格式字符] 具体的说明如下： ① %：表示格式说明的起始符号，不可缺少。 ② -：有-表示左对齐输出，如省略表示右对齐输出。 ③ 0：有0表示指定空位填0,如省略表示指定空位不填。 ④ m.n：m指域宽，即对应的输出项在输出设备上所占的字符数。N指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n=6位。 ⑤ l或h:l对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。 ⑥ 格式字符：用以指定输出项的数据类型和输出格式。 格式字符的总结如下： ① d格式：用来输出十进制整数。 %d：按整型数据的实际长度输出。 %md：m为指定的输出字段的宽度。如果数据的位数小于m，则左端补以空格，若大于m，则按实际位数输出。 %ld：输出长整型数据。 ② o格式：以无符号八进制形式输出整数。对长整型可以用”%lo”格式输出。同样也可以指定字段宽度用“%mo”格式输出。 例： 12345int main() &#123; int a = -1; printf("%d，%o", a, a); return 0;&#125; 上述程序的运行结果为：-1,177777 程序解析：-1在内存单元中（以补码形式存放）为二进制下的 1111111111111111，转换为八进制数为177777。 ③ x格式：以无符号十六进制形式输出整数。对长整型可以用”%lx”格式输出。同样也可以指定字段宽度用”%mx”格式输出。 ④u格式：以无符号十进制形式输出整数。对长整型可以用”%lu”格式输出。同样也可以指定字段宽度用“%mu”格式输出。 ⑤ c格式：输出一个字符。 ⑥s格式：用来输出一个串。 有如下几种用法： 1234printf("%s", "CHINA");//输出"CHINA"字符串（不包括双引号）printf("%10s", "CHINA");//%ms：输出的字符串占m列，如字符串本身长度大于m，则突破获m的限制,将字符串全部 //输出。若串长小于m，则左补空格printf("%-10s", "CHINA");//%-ms：如果串长小于m，则在m列范围内，字符串向左靠，右补空格。 %m.ns：输出占 //m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格。printf("%-10.3s", "CHINA"); //%-m.ns：其中m、n含义同上，n个字符输出在m列范围的左侧，右补空格。如果 //n&gt;m，则自动取n值，即保证n个字符正常输出。 ⑦f格式：用来输出实数（包括单、双精度），以小数形式输出。 %f：不指定宽度，整数部分全部输出并输出6位小数。 %m.nf：输出共占m列，其中有n位小数，如数值宽度小于m左端补空格。 %-m.nf：输出共占n列，其中有n位小数，如数值宽度小于m右端补空格。 ⑧e格式：以指数形式输出实数。 %e：数字部分（又称尾数）输出6位小数，指数部分占5位或4位。 %m.ne和%-m.ne：m、n和”-”字符含义与前相同。此处n指数据的数字部分的小数位数，m表示整个输出数据所占的宽度。 ⑨g格式：自动选f格式或e格式中较短的一种输出，且不输出无意义的零。 Tips：C语言中的逻辑运算符都是短路运算符。一旦能够确定整个表达式的值，就不再进行运算。 Tips：在C99中，double的输出必须用%f，而输入需要用%lf 第一章末的实验： 数据类型实验 实验A1：表达式11111*11111的值是多少？把5个1改成6个1，9个1呢？ 12 实验A2：把实验A1中的所有数换成浮点数，结果如何？ 12 实验A3：表达式sqrt(-10)的值是多少？尝试用各种方式输出。在计算过程中系统会报错吗？ 12345printf("%d\n", sqrt(-10)); //0 //warning: format '%d' expects argument of type 'int', but argument 2 has type //'__gnu_cxx::__enable_if&lt;true, double&gt;::__type &#123;aka double&#125;' [-Wformat=]printf("%f\n", sqrt(-10)); //nan no warnings at all//nan 用于处理计算中出现的错误情况，比如 0.0 除以 0.0 或者求负数的平方根。 实验A4：表达式1.0/0.0、0.0/0.0的值是多少？尝试用各种方式输出。在计算过程中系统会报错吗？ 123456printf("%d\n", 1.0/0.0); //0 warning: format '%d' expects argument of type 'int', but argument 2 has type 'double' [-Wformat=]printf("%d\n", 0.0/0.0); //0 format '%d' expects argument of type 'int', but argument 2 has type 'double' [-Wformat=]printf("%d\n", (int)(1.0/0.0)); //-2147483648printf("%d\n", (int)(0.0/0.0)); //-2147483648printf("%f\n", 1.0/0.0); //infprintf("%f\n", 0.0/0.0); //nan Tips: inf:infinty(linux),等同于#INF:infinity(windows) nan: not a number, 等同于#IND:indeterminate(windows) 注意： inf一般是因为得到的数值，超出浮点数的表示范围（溢出，即阶码部分超过其能表示的最大值）；而nan一般是因为对浮点数进行了未定义的操作，如对-1开方。 nan==nan 结果是0或false，即不能和nan进行比较，和nan进行比较得到的结果总是false或0。所以可以用函数： int isNumber(double d){return (d==d);}来判断d是否为nan，若d是nan则返回0，否则返回非零值。 1.0/0.0等于inf，-1.0/0.0等于-inf，0.0+inf=inf； 对负数开方sqrt(-1.0)、对负数求对数(log(-1.0))、0.0/0.0、0.0*inf、inf/inf、inf-inf这些操作都会得到nan。(0/0会产生操作异常；0.0/0.0不会产生操作异常，而是会得到nan) 得到inf时就查看是否有溢出或者除以0，得到nan时就查看是否有非法操作。 实验A5：表达式1/0的值是多少？在计算过程中会报错吗？ 1printf("%d\n", 1/0); //warning: division by zero [-Wdiv-by-zero] 输入格式实验1234567#include&lt;stdio.h&gt;int main() &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); printf("%d %d\n", a, b); return 0;&#125; 实验B1：在同一行输入12和2，并以空格分隔，是否得到了预期的结果？Yes！ 实验B2：在不同的两行中输入12和2，是否得到了预期的结果？Yes！ 实验B3：在实验B1和B2中，在12和2的前面和后面加入大量的空格或水平制表符，甚至插入一些空行。Yes！ 实验B4：把2换成字符s，重复前三个实验。1：12 2752512 2：12 3305472 3：12 2592768 12 4112384 [totally different!] 第一章末的习题：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//习题1-1 平均数（average）#include&lt;stdio.h&gt;int main() &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); printf("%.3f\n", (a+b+c)/3.0); return 0;&#125;//习题1-2 温度（temperature）#include&lt;stdio.h&gt;int main() &#123; double f; scanf("%lf", &amp;f); double c = 5 * (f-32) / 9; printf("%.3f\n", c); return 0;&#125;//习题1-3 连续和（sum）#include&lt;stdio.h&gt;int main() &#123; int n; scanf("%d", &amp;n); printf("%d\n", n*(n+1)/2); return 0;&#125;//习题1-4 正弦和余弦（sin 和 cos）#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main() &#123; int n; scanf("%d", &amp;n); printf("%f %f\n", sin(n), cos(n)); return 0;&#125;//习题1-5 打折（discount）int main() &#123; int n; scanf("%d", &amp;n); int money = n * 95; if(money &gt;= 300) money = money*0.85; printf("%.2f", money); return 0;&#125;//习题1-6 三角形（triangle）#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int a[3]; scanf("%d%d%d", &amp;a[0], &amp;a[1], &amp;a[2]); sort(a, a+3); if(a[0] + a[1] &lt;= a[2]) printf("not a triangle\n"); else &#123; if(a[0] * a[0] + a[1] * a[1] == a[2] * a[2]) printf("yes\n"); else printf("no\n"); &#125; return 0;&#125;//习题1-7 年份（year）#include&lt;stdio.h&gt;int main() &#123; int year; scanf("%d", &amp;year); if(year%400 == 0) printf("yes\n"); else if(year%4 == 0) printf("yes\n"); else printf("no\n"); return 0;&#125; 第一章末的问题问题1：int型整数的最大值和最小值是多少？1234567#include&lt;stdio.h&gt;int main() &#123; int i = 1; while(i &gt; 0) i++; printf("Min = %d Max = %d\n", i, i-1); return 0;&#125; //组成原理 数据在电脑中的存储细节 问题2：double型浮点数能精确到多少位小数？或者说，这个问题本身值得商榷？问题3：double型浮点数最大正数值和最小正数值是多少？（不必特别精确）问题4：逻辑运算符”&amp;&amp;“ ”||“ ”！“ 的相对优先级是怎样的？ （test a&amp;&amp;b||c)问题5：if(a) if(b) x++; else y++;的确切含义是什么？123if(a) if(b) x++;else y++; Tips：整数范围、浮点数范围和精度、特殊的浮点数、scanf、空格、TAB和回车符的过滤、三角函数使用弧度而非角度； 7744问题：输出形如aabb的4位完全平方数。1234567891011#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main() &#123; for(int a = 1; a &lt;= 9; a++) for(int b = 1; b &lt;= 9; b++)&#123; int n = a * 1100 + b * 11; int m = floor(sqrt(n) + 0.5);//考虑到浮点数计算的误差！！！ if(m*m == n) printf("%d\n", n); &#125; return 0;&#125; Tips:要计算只包含加法、减法和乘法的整数表达式除以正整数n的余数，可以在每步计算之后对n取余，结果不变;循环结构程序设计中最常见的两个问题：算术运算溢出和程序效率低下。 利用时间函数记录程序的运行速度： 12345#include&lt;time.h&gt;int main() &#123; printf("Time used = %.2f\n", (double)clock() /CLOCKS_PER_SEC); return 0;&#125; 通过使用输入输出重定向，让程序从文件中读取数据123freopen("input.txt", "r", stdin);freopen("output.txt", "w", stdout);//在main函数的入口处加入上述代码，使得scanf从文件input.txt读入，printf写入文件output.txt 常规的文件读写操作123456789FILE *fin, *fout;fin = fopen("data.in", "rb");fout = fopen("data.out", "wb");fscanf(fin, "%d", &amp;x);fprintf(fout, "%d", x);fclose(fin);fclose(fout); Tips:在多数据的题目中，要注意某些变量的初始化问题！ ​ 在嵌套的两个代码块中有同名变量时，内层的变量会屏蔽外层变量，有时会引起十分隐蔽的错误！ 第二章末的习题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//习题2-1 水仙花数（daffodil）#include&lt;stdio.h&gt;int main() &#123; for(int i = 100; i &lt;= 999; i++) &#123; int a = i%10; int b = i/10%10; int c = i/100; if(a*a*a + b*b*b +c*c*c == i) printf("%d\n", i); &#125; return 0;&#125;//习题2-2 韩信点兵（hanxin）#include&lt;stdio.h&gt;int main() &#123; int a, b, c; int cnt = 0; while(scanf("%d%d%d", &amp;a, &amp;b, &amp;c) != EOF) &#123; bool flag = true; for(int i = 10; i &lt;= 100; i++) if(i%3 == a &amp;&amp; i%5 == b &amp;&amp; i%7 == c) &#123; flag = false; printf("Case %d: %d\n", ++cnt, i); break; &#125; if(flag) printf("Case %d: No answer\n", ++cnt); &#125; return 0;&#125;//习题2-3 倒三角形（triangle）#include&lt;stdio.h&gt;int main() &#123; int n; while(scanf("%d", &amp;n) != EOF) &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; i; j++) printf(" "); for(int j = 0; j &lt; 2*n-1-2*i; j++) printf("#"); printf("\n"); &#125; &#125; return 0;&#125;//习题2-4 子序列的和（subsequence)#include&lt;stdio.h&gt;int main() &#123; int n, m; int count = 0; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; if(n == 0 &amp;&amp; m == 0) return 0; double cnt = 0; for(int i = n; i &lt;= m; i++) &#123; double temp = 1.0 / i; temp *= temp; cnt += temp; &#125; printf("Case %d: %.5f", ++count, cnt); &#125;&#125;//习题2-5 分数化小数（decimal）#include&lt;stdio.h&gt;int main() &#123; int a, b, c, cnt = 0; while(scanf("%d%d%d", &amp;a, &amp;b, &amp;c) != EOF) &#123; if(a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0) return 0; double temp = a * 1.0 / b; printf("Case %d: %.*lf\n", ++cnt, c, temp);//printf("%*.*f\n", m, n, ch); &#125; return 0;&#125;//习题2-6 排列（permutation）#include&lt;stdio.h&gt;int main() &#123; int a[3]; for(a[0] = 123; a[0] &lt;=329; a[0]++) &#123; a[1] = a[0] * 2; a[2] = a[0] * 3; int c[9]; for(int m = 0; m &lt; 9; m += 3) &#123; c[m+2] = a[m/3]%10; c[m+1] = a[m/3]/10%10; c[m] = a[m/3]/100; &#125; int add = 0, mul = 1; for(int i = 0; i &lt; 9; i++) &#123; add += c[i]; mul *= c[i]; &#125; if(add == 45 &amp;&amp; mul == 362880) printf("%d %d %d\n", a[0], a[1], a[2]); &#125; return 0;&#125; 第二章末的问题题目1：假设需要输出2，4，6，8，…,2n，每个一行，能不能通过对程序2-1进行小小的改动来实现？ 123456789//程序2-1#include&lt;stdio.h&gt;int main() &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) printf("%d\n", i); return 0;&#125; 任务1：改动第7行，不改动第6行 12for(int i = 0; i &lt; n; i++) printf("%d\n", (i+1)*2); 任务2：改动第6行，不改动第7行 12for(int i = 2; i &lt;= 2*n; i += 2) printf("%d\n", i); 题目2：下面程序的运行结果是什么？ 无法停止，因为i存在误差，无法判定与10相等。 1234567#include&lt;stdio.h&gt;int main() &#123; double i; for(i = 0; i != 10; i += 0.1) printf("%.lf\n", i); return 0;&#125;]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何编写一个简单的shellcode]]></title>
    <url>%2F2018%2F08%2F23%2F%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84shellcode%2F</url>
    <content type="text"><![CDATA[如何编写一个简单的shellcode1、写在前面​ 最近在准备《安全编程》的考试，感觉shellcode学起来懵懵的&gt; &lt;但是！！！身为一个信息安全专业的学生，不会写shellcode简直就是死咸鱼啊！Shellcode是探测到漏洞时执行的代码，是漏洞利用时十分重要的一块内容~请跟本咸鱼一起来学习一个[围笑]。 2、系统调用函数execve示例代码1： 123456789//shellcode.c#include&lt;unistd.h&gt;int main(int argc, char* argv[]) &#123; char* name[2]; name[0] = "bin/ksh"; name[1] = NULL; execve(name[0], name, NULL); return 0;&#125; ​ *通过系统调用execve函数来返回shell。 ​ 从上述程序中可以看出，在c语言中调用execve函数来返回shell时，需要包含相应的头文件，在主函数中调用execve函数，同时传入三个参数。 execve函数的介绍： ​ execve（执行文件）在父进程中fork一个子进程，在子进程中调用exec函数启动新的程序。execve是内核级调用函数。 ​ 函数定义 int execve（const char filename, char const argv[], char* const envp[]） ​ 返回值 执行成功时没有返回值，执行失败时的返回值为-1. ​ 函数说明 execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执行文件，并且需要以NULL指针结束，最后一个参数则为传递给执行文件的新环境变量数组。 示例代码2： 123456#include&lt;unistd.h&gt;int main() &#123; char* argv[] = &#123;"ls", "-al", "/etc/passwd", NULL&#125;; char* envp[] = &#123;"PATH = /bin", NULL&#125;; execve("/bin/ls", argv, envp);&#125; ​ 上述代码实现的功能：与在bin目录下执行 ls -al /etc/passwd 是相同的。 ​ 通过在http://syscalls.kernelgrok.com查询到的系统调用表，可以获得sys_execve函数的相关信息： ​ execve函数的系统调用号为11，对应的寄存器中保留的参数值分别为：eax：0x0b（11！）; ebx：char _user*; ecx：char _user* user*; edx：char _user* user*; esi：struct pt_regs *; edi：—。 3、用汇编语言来编写shellcode​ 通过反编译获得的汇编代码来研究如何用汇编语言编写shellcode。 ​ 对示例代码1进行如下操作： ​ 1、编译所编写的代码。 1[scz@ /home/scz/src]&gt; gcc -o shellcode –g gdb -static shellcode.c ​ 2、用gdb调试执行代码，对main进行反汇编。 1234567891011121314151617181920212223[scz@ /home/scz/src]&gt; gdb shellcodeGNU gdb 4.17.0.11 with Linux supportThis GDB was configured as "i386-redhat-linux"...(gdb) disassemble main &lt;-- -- -- 输入Dump of assembler code for function main:0x80481a0 : pushl %ebp0x80481a1 : movl %esp,%ebp //设置新的栈底0x80481a3 : subl $0x8,%esp //设置新的栈顶0x80481a6 : movl $0x806f308,0xfffffff8(%ebp) //name[0]的地址0x80481ad : movl $0x0,0xfffffffc(%ebp) //name[1]的地址0x80481b4 : pushl $0x0 //压入execve的第3个参数0x80481b6 : leal 0xfffffff8(%ebp),%eax0x80481b9 : pushl %eax //压入execve的第2个参数0x80481ba : movl 0xfffffff8(%ebp),%eax0x80481bd : pushl %eax //压入execve的第1个参数0x80481be : call 0x804b9b0 &lt;__execve&gt; //调用execve0x80481c3 : addl $0xc,%esp //恢复栈顶0x80481c6 : xorl %eax,%eax0x80481c8 : jmp 0x80481d0 0x80481ca : leal 0x0(%esi),%esi0x80481d0 : leave //释放当前子程序在堆栈中的局部变量0x80481d1 : retEnd of assembler dump. ​ 3、对execve函数进行反汇编。 12345678910111213(gdb) disas __execve &lt;-- -- -- 输入Dump of assembler code for function __execve:0x804b9b0 &lt;__execve&gt;: pushl %ebx0x804b9b1 &lt;__execve+1&gt;: movl 0x10(%esp,1),%edx0x804b9b5 &lt;__execve+5&gt;: movl 0xc(%esp,1),%ecx0x804b9b9 &lt;__execve+9&gt;: movl 0x8(%esp,1),%ebx0x804b9bd &lt;__execve+13&gt;: movl $0xb,%eax0x804b9c2 &lt;__execve+18&gt;: int $0x800x804b9c4 &lt;__execve+20&gt;: popl %ebx0x804b9c5 &lt;__execve+21&gt;: cmpl $0xfffff001,%eax0x804b9ca &lt;__execve+26&gt;: jae 0x804bcb0 &lt;__syscall_error&gt;0x804b9d0 &lt;__execve+32&gt;: retEnd of assembler dump. ​ 4、研究main函数的汇编代码。 123456789101112131415161718192021222324252627282930313233343536370x80481a0 : pushl %ebp # 保存原来的栈基指针 # 栈基指针与堆栈指针不是一个概念 # 栈基指针对应栈底，堆栈指针对应栈顶0x80481a1 : movl %esp,%ebp # 修改得到新的栈基指针 # 与在dos下汇编格式不一样 # 这个语句是说把esp的值赋给ebp # 而在dos下，正好是反过来的，一定要注意0x80481a3 : subl $0x8,%esp # 堆栈指针向栈顶移动八个字节 # 用于分配局部变量的存储空间 # 这里具体就是给 char * name[2] 预留空间 # 因为每个字符指针占用4个字节，总共两个指针0x80481a6 : movl $0x806f308,0xfffffff8(%ebp) # 将字符串"/bin/ksh"的地址拷贝到name[0] # name[0] = "/bin/ksh"; # 0xfffffff8(%ebp) 就是 ebp - 8 的意思 # 注意堆栈的增长方向以及局部变量的分配方向 # 先分配name[0]后分配name[1]的空间0x80481ad : movl $0x0,0xfffffffc(%ebp) # 将NULL拷贝到name[1] # name[1] = NULL;0x80481b4 : pushl $0x0 # 按从右到左的顺序将execve()的三个参数依次压栈 # 首先压入 NULL (第三个参数) # 注意pushl将压入一个四字节长的00x80481b6 : leal 0xfffffff8(%ebp),%eax # 将 ebp - 8 本身放入eax寄存器中 # leal的意思是取地址，而不是取值0x80481b9 : pushl %eax # 其次压入 name0x80481ba : movl 0xfffffff8(%ebp),%eax0x80481bd : pushl %eax # 将 ebp - 8 本身放入eax寄存器中 # 最后压入 name[0] # 即 "/bin/ksh" 字符串的地址0x80481be : call 0x804b9b0 &lt;__execve&gt; # 开始调用 execve() # call指令首先会将返回地址压入堆栈0x80481c3 : addl $0xc,%esp # esp + 12 # 释放为了调用 execve() 而压入堆栈的内容0x80481c6 : xorl %eax,%eax0x80481c8 : jmp 0x80481d0 0x80481ca : leal 0x0(%esi),%esi0x80481d0 : leave0x80481d1 : ret ​ 5、研究execve函数的汇编代码。Linux在寄存器里传递它的参数给系统调用，用软件中断跳到kernel模式(int$0x80)。 12345678910111213141516171819200x804b9b0 &lt;__execve&gt;: pushl %ebx # ebx压栈0x804b9b1 &lt;__execve+1&gt;: movl 0x10(%esp,1),%edx # 把 esp + 16 本身赋给edx # 为什么是16，因为栈顶现在是ebx # 下面依次是返回地址、name[0]、name、NULL # edx --&gt; NULL0x804b9b5 &lt;__execve+5&gt;: movl 0xc(%esp,1),%ecx # 把 esp + 12 本身赋给 ecx # ecx --&gt; name # 命令的参数数组，包括命令自己0x804b9b9 &lt;__execve+9&gt;: movl 0x8(%esp,1),%ebx # 把 esp + 8 本身赋给 ebx # ebx --&gt; name[0] # 命令本身，"/bin/ksh"0x804b9bd &lt;__execve+13&gt;: movl $0xb,%eax # 设置eax为0xb，这是syscall表中的索引 # 0xb对应execve0x804b9c2 &lt;__execve+18&gt;: int $0x80 # 软件中断，转入kernel模式0x804b9c4 &lt;__execve+20&gt;: popl %ebx # 恢复ebx0x804b9c5 &lt;__execve+21&gt;: cmpl $0xfffff001,%eax0x804b9ca &lt;__execve+26&gt;: jae 0x804bcb0 &lt;__syscall_error&gt; # 判断返回值，报告可能的系统调用错误0x804b9d0 &lt;__execve+32&gt;: ret # execve() 调用返回 # 该指令会用压在堆栈中的返回地址 ​ Shellcode的开发过程： ​ 从上面的分析可以看出，完成execve() 系统调用，我们所要做的不过是这么几项而已： a) 在内存中有以NULL结尾的字符串&quot;/bin/ksh&quot; ​ b) 在内存中有”/bin/ksh”的地址，其后是一个 unsigned long 型的NULL值 ​ c) 将0xb拷贝到寄存器EAX中 ​ d) 将”/bin/ksh”的地址拷贝到寄存器EBX中 ​ e) 将”/bin/ksh”地址的地址拷贝到寄存器ECX中 ​ f) 将 NULL 拷贝到寄存器EDX中 ​ g) 执行中断指令int $0x80 如果execve()调用失败的话，程序将继续从堆栈中获取指令并执行，而此时堆栈中的数据是随机的，通常这个程序会coredump。我们希望如果execve调用失败的话，程序可以正常退出，因此我们必须在execve调用后增加一个exit系统调用。它的C语言程序如下： 1234//shellcode_exit.cint main ()&#123; exit(0);&#125; ​ 汇编语言代码如下： 1234567891011121314[scz@ /home/scz/src]&gt; gcc -o shellcode_exit -static shellcode_exit.c[scz@ /home/scz/src]&gt; gdb shellcode_exitGNU gdb 4.17.0.11 with Linux supportThis GDB was configured as "i386-redhat-linux"...(gdb) disas _exit &lt;-- -- -- 输入Dump of assembler code for function _exit:0x804b970 &lt;_exit&gt;: movl %ebx,%edx0x804b972 &lt;_exit+2&gt;: movl 0x4(%esp,1),%ebx0x804b976 &lt;_exit+6&gt;: movl $0x1,%eax0x804b97b &lt;_exit+11&gt;: int $0x800x804b97d &lt;_exit+13&gt;: movl %edx,%ebx0x804b97f &lt;_exit+15&gt;: cmpl $0xfffff001,%eax0x804b984 &lt;_exit+20&gt;: jae 0x804bc60 &lt;__syscall_error&gt;End of assembler dump. ​ 我们可以看到，exit系统调用将0x1放到EAX中(这是它的syscall索引值)，将退出码放入EBX中，然后执行”int$0x80”。大部分程序正常退出时返回0值，我们也在EBX中放入0。 ​ 现在我们所要完成的工作又增加了三项： ​ h) 将0x1拷贝到寄存器EAX中 i) 将0x0拷贝到寄存器EBX中 j) 执行中断指令int $0x80 ​ 同时，要注意不能出现0x00，要避免中途被截断。理清任务之后，可以很容易地用汇编语言写出shellcode： 1234567891011121314151617section .textglobal _start_start:xor eax,eaxpush eaxpush 0x68732f2f ；压入&quot;//sh&quot;push 0x6e69622f ；压入&quot;/bin&quot;mov ebx,esp ；将字符串的地址存入ebxpush eax ；压入&quot;0x00&quot;push ebx ；压入字符串&quot;/bin//sh&quot;的地址mov ecx,esp ；将指针数组地址存入ecxxor edx,edx ；[edx] = 0mov al,0xb ；将11写入eax，execve的系统调用号int 0x80mov al,0x1xor ebx,ebxint 0x80 ​ 根据之前int 0x80中断指令调用形式，要求eax存放系统调用号;ebx、ecx、edx分别存放参数部分。 ​ 汇编源码中，首先是第4行eax清零；之后第5行压栈；然后第6行，第7行字符串压栈，这样在栈中就构造了以”\x00”结尾的字符串”/bin//sh”。注意这里的“/bin//sh”与“/bin/sh”同样效果。此时的ESP指针指向了这个字符串首地址，第8行将该首地址赋给ebx，这样就有了int 0x80中断指令的第一个参数ebx；第9行中eax入栈，此时eax值还是0；第10行ebx入栈也就是把字符串”/bin//sh”地址入栈，两次压栈，此时栈中就有了字符串地址和一个0，刚好构成了一个指针数组；第11行将该指针数组的地址也就是esp赋给ecx，系统调用的第2个参数ecx中就保持了指针数组的地址；第12行edx清零，刚好是系统调用的第3个参数为零。第13行将系统调用号0xB赋给al,这样可以避免出现坏字符。最后调用软中断指令执行。 4、练习和示例*FreeBSD 堆栈 ；Linux 寄存器 1、编写如下c语言程序对应的shellcode： 1234int main() &#123; wirte(1, "hello, world\n",15); exit(0);&#125; ​ jmp/call方法，FreeBSD 1234567891011121314151617181920global _start_start:xor eax, eaxjmp short stringcode:pop esipush byte 15push esipush byte 1mov al,4push eaxint 0x80xor eax,eaxpush eaxpush eaxmov al,1int 0x80string:call codedb &quot;hello, world!&quot;, 0x0a 2、编写如下c语言程序对应的shellcode： 123int main() &#123; execve("/bin/sh",0,0);&#125; ​ push方法，FreeBSD 123456789101112BITS 32xor eax,eaxpush eaxpush 0x68732f6epush 0x69622f2fmov ebx,esppush eaxpush eaxpush ebxmov al,59push eaxint 80h 3、在Linux环境下分别用jmp/call方法和push方法各写一个汇编程序，完成如下c语言程序所要完成的功能，以便形成对应的shellcode。 123int main(void) &#123; execve("/bin/ksh",0,0);&#125; ​ push方法： 12345678910BITS 32xor eax,eaxxor edx,edxpush eaxpush &quot;/ksh&quot;push &quot;/bin&quot;mov ebx,espxor ecx,ecxmov al,0xbint 0x80 ​ jmp/call方法： 123456789101112BITS 32xor eax,eaxjmp short stringcode:pop ebxxor ecx,ecxxor edx,edxmov al,0xbint 0x80string:call codedb &quot;/bin/ksh&quot; 0x0 4、汇编语言直接编写shellcode(jmp/call方法，FreeBSD环境下）执行： 12345678int main() &#123; char *command="/bin/sh"; char *args[2]; args[0]=command; args[1]=0; execve(command,args,0);&#125;//第一个参数是字符串"/bin/sh"的地址 ​ jmp/call方法： 1234567891011121314151617181920global _start_start:xor eax, eaxjmp short stringcode:pop esipush eaxpush esipush esimov al,0xbpush eaxint 0x80xor eax,eaxpush eaxpush eaxmov al,1int 0x80string:call codedb &quot;/bin/sh&quot;, 0x0]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中&a与&a[0]的区别]]></title>
    <url>%2F2018%2F04%2F08%2F%E6%95%B0%E7%BB%84%E4%B8%AD%26a%E4%B8%8E%26a%5B0%5D(%E5%8D%B3a)%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[数组中&amp;a与&amp;a[0](即a)的区别​ 在newcoder上写数组相关题目时遇到了这样一个问题： 12345//以下 C 语言指令：int a[5] = &#123;1,3,5,7,9&#125;;int *p = (int *)(&amp;a+1);printf(“%d,%d”,*(a+1) ， *(p-1));//运行结果是什么？ ​ 读者可以先自己思考一下这个问题~ 在这道题中，*(a+1)的输出结果是非常常规容易思考的，而*(int*)(&amp;a+1)的输出结果则需要一定的思考。 ​ 下面公布正确答案：3,9。 ​ 题目中首先定义了一个可以存在 ​ 题目中首先定义了存放5个int类型空间大小的内存，然后初始化5个数。我们知道直接使用数组的名字a表示的是一个指向数组首地址的指针，所以直接a与&amp;a[0]是相同的意思，都表示数组的首地址。所以(a+1)很好理解，假设a地址是0x1000，就是取（0x1000+sizeof(int)）地址的数，由于数组的物理地址是连续的，当然就是取2。 那&amp;a表示什么意思呢，相当于取存放指向数组首地址的指针的存储地址，话有些绕，但是细细品味你就会发现，它就相当于二维指针，假设每个一维指针指向一排数组（当然除了第一个一维数组的指针之外实际都没有申请，但是在访问野指针之前计算机也不知道那块地址是否存在，但的确可以由物理地址连续性来获取这块地址的表示），**所以简言之&amp;a表示第一排数组，&amp;a+1就是表示第二排数组（就是5\sizeof(int)=54=20空间大小后一段空间的首地址）。** 有了上面的介绍就好理解了，(ptr-1)是表示取(0x1000+5sizeof(int)-sizeof(int))地址中的数，算得为5。 总结： *&amp;a[0]表示数组的首地址，与直接a相同意义。而&amp;a表示存储指向数组首地址的指针的地址，可以用二维指针来理解。 *(int*)(&amp;a+1)]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newcoder 清华 10进制 VS 2进制]]></title>
    <url>%2F2018%2F04%2F01%2F%E6%B8%85%E5%8D%8E%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[清华复试上机 10进制 VS 2进制 题解题目描述​ 对于一个十进制数A，将A转换为二进制数，然后按位逆序排列，再转换为十进制数B，我们乘B为A的二进制逆序数。 例如对于十进制数173，它的二进制形式为10101101，逆序排列得到10110101，其十进制数为181，181即为173的二进制逆序数。 输入描述:1一个1000位(即10^999)以内的十进制数。 输出描述:1输入的十进制数的二进制逆序数。 ​ 这是本人目前刷题到现在最讨厌的题型，大整数的各种操作。因为超过了long long 的表示范围，所以只能用字符串或者int数组来存储数据，然后逐位操作。 ​ 这里使用string类型来存储大整数滴~ ​ 需要实现的功能函数有：字符串的除法、加法和乘法。思路都非常简单一致，就是按照运算规则，从高位到低位(除法)、从低位到高位(加法、乘法)逐位来进行运算。 ​ 字符串的除法(因为是转换成二进制，所以是计算除以2的情况)： 123456789101112string div(string s) &#123; string ret = ""; int now = 0; for(int i = 0; i &lt; s.length(); i++) &#123;//从高位到低位 now = now * 10 + (s[i] - '0'); if(ret == "" &amp;&amp; now / 2 == 0) continue;//除去先导0 ret = ret + char('0' + now / 2); now %= 2; &#125; if(ret == "") ret = "0"; return ret;&#125; ​ 字符串的加法： 12345678910string add(string s) &#123; int c = 1, tmp; for(int i = s.length() - 1; i &gt;= 0; i--) &#123; tmp = (s[i] - &apos;0&apos;) + c; s[i] = char(tmp % 10 + &apos;0&apos;); c = tmp / 10;//c现在用来保存进位 if(c == 0) return s;//如果进位停止则说明之后的数字不会发生变化，直接返回 &#125; return &quot;1&quot; + s;//最多进一位1&#125; ​ 字符串的乘法(*2)： 12345678910string mul(string s) &#123; int c = 0, tmp; for(int i = s.length() - 1; i &gt;= 0; i--) &#123; tmp = (s[i] - &apos;0&apos;) * 2 + c; s[i] = char(tmp % 10 + &apos;0&apos;); c = tmp / 10; &#125; if(c) s = char(c + &apos;0&apos;) + s; return s;&#125; ​ 整体的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;string div(string s) &#123; string ret = ""; int now = 0; for(int i = 0; i &lt; s.length(); i++) &#123; now = now * 10 + (s[i] - '0'); if(ret == "" &amp;&amp; now / 2 == 0) continue; ret = ret + char('0' + now / 2); now %= 2; &#125; if(ret == "") ret = "0"; return ret;&#125;string add(string s) &#123; int c = 1, tmp; for(int i = s.length() - 1; i &gt;= 0; i--) &#123; tmp = (s[i] - '0') + c; s[i] = char(tmp % 10 + '0'); c = tmp / 10; if(c == 0) return s; &#125; return "1" + s;&#125;string mul(string s) &#123; int c = 0, tmp; for(int i = s.length() - 1; i &gt;= 0; i--) &#123; tmp = (s[i] - '0') * 2 + c; s[i] = char(tmp % 10 + '0'); c = tmp / 10; &#125; if(c) s = char(c + '0') + s; return s;&#125;int main() &#123; string num; while(cin &gt;&gt; num) &#123; int tmp; string ans = "0"; while(num != "0") &#123; tmp = num[num.length() - 1] - '0';//最后一位 ans = mul(ans); if(tmp &amp; 1) &#123; num[num.length() - 1]--; ans = add(ans); &#125; num = div(num); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newcoder 清华 最小邮票数]]></title>
    <url>%2F2018%2F04%2F01%2F%E6%9C%80%E5%B0%8F%E9%82%AE%E7%A5%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[清华复试上机 最小邮票数 题解题目描述：​ 有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。 输入描述:1有多组数据，对于每组数据，首先是要求凑成的邮票总值M，M&lt;100。然后是一个数N，N〈20，表示有N张邮票。接下来是N个正整数，分别表示这N张邮票的面值，且以升序排列。 输出描述:1对于每组数据，能够凑成总值M的最少邮票张数。若无解，输出0。 ​ 本题是一个01背包的变形，将每张邮票的价值看作1，要求在背包容量必须装满的情况下，价值达到最小。可以用动态规划来解决。 ​ 可以用一个二维数组dp[i][j]来表示在前i张里面填满空间j的最小邮票张数，则有dp[i][j] = min(dp[i -1][j] , dp[i - 1][j - ticket[i]] + 1) 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int M, N; int dp[101]; int ticket[21]; while(cin &gt;&gt; M &gt;&gt; N) &#123; for(int i = 0; i &lt; N; i++) cin &gt;&gt; ticket[i];//用数组ticket来存储第i张邮票的价值 for(int i = 0; i &lt; 101; i++) dp[i] = N + 1;//面值为i时需要的邮票数量,将其统一初始化为当前的最大值N+1 dp[0] = 0; dp[ticket[0]] = 1; for(int i = 1; i &lt;= N; i++) &#123;//i张邮票 for(int j = M; j &gt;= ticket[i]; j--) &#123; dp[j] = min(dp[j], dp[j - ticket[i]] + 1); &#125; &#125; if(dp[M] &lt;= N) cout &lt;&lt; dp[M] &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典习题2-5题解]]></title>
    <url>%2F2018%2F03%2F31%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E4%B9%A0%E9%A2%98%E9%A2%98%E8%A7%A3%20%2F</url>
    <content type="text"><![CDATA[算法竞赛入门经典习题2-5分数化小数(decimal)题目描述： ​ 输入正整数a, b, c, 输出a/b的小数形式，精确到小数点后c位。a,b &lt;= 10 ^ 6$, $c &lt;= 100。 输入包含多组数据，结束标记为a = b = c = 0。 ​ 因为这道题发现了printf的一种神奇的用法0.0。 1printf("%*.*lf\n", a, b, (double) c / d); ​ 其中，格式控制符%a.bf 表达的含义是：打印a位有效数字的b位小数。 %f是打印实数数据（float double类型的数据） a表示有效数字个数，b表示小数点后的位数。在本题中，只限制了小数点后的位数是c位，因此代码如下： 123456789101112#include&lt;stdio.h&gt;int main() &#123; int a, b, c; while(1) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); if(a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0) break; double ans = (double)a / b; printf("%.*f\n", c, ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程连接服务器的操作说明]]></title>
    <url>%2F2017%2F12%2F10%2F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[远程连接服务器的操作说明​ 在本科阶段的学习中，我们经常接触到服务器的概念。但很多同学都像我一样没有实际接触和操作过远程服务器。在真实的项目中，不知道如何操作自己远在千里之外的云端服务器。在本文中，笔者将以一个初学者的角度，详细地说明如何操作远程服务器、上传自己的资源、第一个网站的开发与发布过程。 一、有关服务器的简单操作1、 远程连接服务器​ 需要的知识储备：linux操作系统下常用的指令、linux文件系统的结构 ​ 需要的软件：仅列举本人实际使用过的putty和Xshell。（下文以putty的界面为例） ​ 在界面中输入下列信息: 主机名称：120.78.182.65 （这是本人测试开发用的服务器的外网ip，仅作示例。在这里填写自己要连接的远程服务器的ip地址即可） 端口号：22 退出时关闭系统：仅正常退出 然后点击打开，即看到如下界面： ​ 在login as: 提示后输入自己想要登陆的用户名（若输入root后，则以root身份登入服务器。）在界面提示输入密码时，输入自己设置好的密码。 ​ 敲击回车键，看到如下界面即为登入成功，可进行一系列操作。（此时的操作全部会同步到远程服务器端。） 2、 将本地的网站资源上传至服务器​ 下载一个文档上传用的软件，本文以FileZilla为例,完成安装后运行，看到如图所示界面。 点击菜单栏的“文件”选项，选择站点管理器，完成如下配置。 ​ 主机名和端口号与上文叙述的一致，协议选择SFTP。在用户名和密码栏填写自己想要在远程服务器端登陆的用户名和对应的密码。考虑到项目资源管理的独立性，一般来说，不建议以root用户登陆。 ​ 点击连接。看到如下界面即为连接成功。 ​ 本地站点的文件目录即为本地机器的文件目录，右侧即为服务器的文件目录，可通过更改远程站点栏的路径名，查看服务器各个文件目录下的资源。Apache2的默认网站路径为/var/www/html，将资源上传至这个目录下即可在浏览器得到显示。]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
