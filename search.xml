<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何编写一个简单的shellcode]]></title>
    <url>%2F2018%2F08%2F23%2F%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84shellcode%2F</url>
    <content type="text"><![CDATA[如何编写一个简单的shellcode1、写在前面​ 最近在准备《安全编程》的考试，感觉shellcode学起来懵懵的&gt; &lt;但是！！！身为一个信息安全专业的学生，不会写shellcode简直就是死咸鱼啊！Shellcode是探测到漏洞时执行的代码，是漏洞利用时十分重要的一块内容~请跟本咸鱼一起来学习一个[围笑]。 2、系统调用函数execve示例代码1： 123456789//shellcode.c#include&lt;unistd.h&gt;int main(int argc, char* argv[]) &#123; char* name[2]; name[0] = "bin/ksh"; name[1] = NULL; execve(name[0], name, NULL); return 0;&#125; ​ *通过系统调用execve函数来返回shell。 ​ 从上述程序中可以看出，在c语言中调用execve函数来返回shell时，需要包含相应的头文件，在主函数中调用execve函数，同时传入三个参数。 execve函数的介绍： ​ execve（执行文件）在父进程中fork一个子进程，在子进程中调用exec函数启动新的程序。execve是内核级调用函数。 ​ 函数定义 int execve（const char filename, char const argv[], char* const envp[]） ​ 返回值 执行成功时没有返回值，执行失败时的返回值为-1. ​ 函数说明 execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用数组指针来传递给执行文件，并且需要以NULL指针结束，最后一个参数则为传递给执行文件的新环境变量数组。 示例代码2： 123456#include&lt;unistd.h&gt;int main() &#123; char* argv[] = &#123;"ls", "-al", "/etc/passwd", NULL&#125;; char* envp[] = &#123;"PATH = /bin", NULL&#125;; execve("/bin/ls", argv, envp);&#125; ​ 上述代码实现的功能：与在bin目录下执行 ls -al /etc/passwd 是相同的。 ​ 通过在http://syscalls.kernelgrok.com查询到的系统调用表，可以获得sys_execve函数的相关信息： ​ execve函数的系统调用号为11，对应的寄存器中保留的参数值分别为：eax：0x0b（11！）; ebx：char _user*; ecx：char _user* user*; edx：char _user* user*; esi：struct pt_regs *; edi：—。 3、用汇编语言来编写shellcode​ 通过反编译获得的汇编代码来研究如何用汇编语言编写shellcode。 ​ 对示例代码1进行如下操作： ​ 1、编译所编写的代码。 1[scz@ /home/scz/src]&gt; gcc -o shellcode –g gdb -static shellcode.c ​ 2、用gdb调试执行代码，对main进行反汇编。 1234567891011121314151617181920212223[scz@ /home/scz/src]&gt; gdb shellcodeGNU gdb 4.17.0.11 with Linux supportThis GDB was configured as "i386-redhat-linux"...(gdb) disassemble main &lt;-- -- -- 输入Dump of assembler code for function main:0x80481a0 : pushl %ebp0x80481a1 : movl %esp,%ebp //设置新的栈底0x80481a3 : subl $0x8,%esp //设置新的栈顶0x80481a6 : movl $0x806f308,0xfffffff8(%ebp) //name[0]的地址0x80481ad : movl $0x0,0xfffffffc(%ebp) //name[1]的地址0x80481b4 : pushl $0x0 //压入execve的第3个参数0x80481b6 : leal 0xfffffff8(%ebp),%eax0x80481b9 : pushl %eax //压入execve的第2个参数0x80481ba : movl 0xfffffff8(%ebp),%eax0x80481bd : pushl %eax //压入execve的第1个参数0x80481be : call 0x804b9b0 &lt;__execve&gt; //调用execve0x80481c3 : addl $0xc,%esp //恢复栈顶0x80481c6 : xorl %eax,%eax0x80481c8 : jmp 0x80481d0 0x80481ca : leal 0x0(%esi),%esi0x80481d0 : leave //释放当前子程序在堆栈中的局部变量0x80481d1 : retEnd of assembler dump. ​ 3、对execve函数进行反汇编。 12345678910111213(gdb) disas __execve &lt;-- -- -- 输入Dump of assembler code for function __execve:0x804b9b0 &lt;__execve&gt;: pushl %ebx0x804b9b1 &lt;__execve+1&gt;: movl 0x10(%esp,1),%edx0x804b9b5 &lt;__execve+5&gt;: movl 0xc(%esp,1),%ecx0x804b9b9 &lt;__execve+9&gt;: movl 0x8(%esp,1),%ebx0x804b9bd &lt;__execve+13&gt;: movl $0xb,%eax0x804b9c2 &lt;__execve+18&gt;: int $0x800x804b9c4 &lt;__execve+20&gt;: popl %ebx0x804b9c5 &lt;__execve+21&gt;: cmpl $0xfffff001,%eax0x804b9ca &lt;__execve+26&gt;: jae 0x804bcb0 &lt;__syscall_error&gt;0x804b9d0 &lt;__execve+32&gt;: retEnd of assembler dump. ​ 4、研究main函数的汇编代码。 123456789101112131415161718192021222324252627282930313233343536370x80481a0 : pushl %ebp # 保存原来的栈基指针 # 栈基指针与堆栈指针不是一个概念 # 栈基指针对应栈底，堆栈指针对应栈顶0x80481a1 : movl %esp,%ebp # 修改得到新的栈基指针 # 与在dos下汇编格式不一样 # 这个语句是说把esp的值赋给ebp # 而在dos下，正好是反过来的，一定要注意0x80481a3 : subl $0x8,%esp # 堆栈指针向栈顶移动八个字节 # 用于分配局部变量的存储空间 # 这里具体就是给 char * name[2] 预留空间 # 因为每个字符指针占用4个字节，总共两个指针0x80481a6 : movl $0x806f308,0xfffffff8(%ebp) # 将字符串"/bin/ksh"的地址拷贝到name[0] # name[0] = "/bin/ksh"; # 0xfffffff8(%ebp) 就是 ebp - 8 的意思 # 注意堆栈的增长方向以及局部变量的分配方向 # 先分配name[0]后分配name[1]的空间0x80481ad : movl $0x0,0xfffffffc(%ebp) # 将NULL拷贝到name[1] # name[1] = NULL;0x80481b4 : pushl $0x0 # 按从右到左的顺序将execve()的三个参数依次压栈 # 首先压入 NULL (第三个参数) # 注意pushl将压入一个四字节长的00x80481b6 : leal 0xfffffff8(%ebp),%eax # 将 ebp - 8 本身放入eax寄存器中 # leal的意思是取地址，而不是取值0x80481b9 : pushl %eax # 其次压入 name0x80481ba : movl 0xfffffff8(%ebp),%eax0x80481bd : pushl %eax # 将 ebp - 8 本身放入eax寄存器中 # 最后压入 name[0] # 即 "/bin/ksh" 字符串的地址0x80481be : call 0x804b9b0 &lt;__execve&gt; # 开始调用 execve() # call指令首先会将返回地址压入堆栈0x80481c3 : addl $0xc,%esp # esp + 12 # 释放为了调用 execve() 而压入堆栈的内容0x80481c6 : xorl %eax,%eax0x80481c8 : jmp 0x80481d0 0x80481ca : leal 0x0(%esi),%esi0x80481d0 : leave0x80481d1 : ret ​ 5、研究execve函数的汇编代码。Linux在寄存器里传递它的参数给系统调用，用软件中断跳到kernel模式(int$0x80)。 12345678910111213141516171819200x804b9b0 &lt;__execve&gt;: pushl %ebx # ebx压栈0x804b9b1 &lt;__execve+1&gt;: movl 0x10(%esp,1),%edx # 把 esp + 16 本身赋给edx # 为什么是16，因为栈顶现在是ebx # 下面依次是返回地址、name[0]、name、NULL # edx --&gt; NULL0x804b9b5 &lt;__execve+5&gt;: movl 0xc(%esp,1),%ecx # 把 esp + 12 本身赋给 ecx # ecx --&gt; name # 命令的参数数组，包括命令自己0x804b9b9 &lt;__execve+9&gt;: movl 0x8(%esp,1),%ebx # 把 esp + 8 本身赋给 ebx # ebx --&gt; name[0] # 命令本身，"/bin/ksh"0x804b9bd &lt;__execve+13&gt;: movl $0xb,%eax # 设置eax为0xb，这是syscall表中的索引 # 0xb对应execve0x804b9c2 &lt;__execve+18&gt;: int $0x80 # 软件中断，转入kernel模式0x804b9c4 &lt;__execve+20&gt;: popl %ebx # 恢复ebx0x804b9c5 &lt;__execve+21&gt;: cmpl $0xfffff001,%eax0x804b9ca &lt;__execve+26&gt;: jae 0x804bcb0 &lt;__syscall_error&gt; # 判断返回值，报告可能的系统调用错误0x804b9d0 &lt;__execve+32&gt;: ret # execve() 调用返回 # 该指令会用压在堆栈中的返回地址 ​ Shellcode的开发过程： ​ 从上面的分析可以看出，完成execve() 系统调用，我们所要做的不过是这么几项而已： a) 在内存中有以NULL结尾的字符串&quot;/bin/ksh&quot; ​ b) 在内存中有”/bin/ksh”的地址，其后是一个 unsigned long 型的NULL值 ​ c) 将0xb拷贝到寄存器EAX中 ​ d) 将”/bin/ksh”的地址拷贝到寄存器EBX中 ​ e) 将”/bin/ksh”地址的地址拷贝到寄存器ECX中 ​ f) 将 NULL 拷贝到寄存器EDX中 ​ g) 执行中断指令int $0x80 如果execve()调用失败的话，程序将继续从堆栈中获取指令并执行，而此时堆栈中的数据是随机的，通常这个程序会coredump。我们希望如果execve调用失败的话，程序可以正常退出，因此我们必须在execve调用后增加一个exit系统调用。它的C语言程序如下： 1234//shellcode_exit.cint main ()&#123; exit(0);&#125; ​ 汇编语言代码如下： 1234567891011121314[scz@ /home/scz/src]&gt; gcc -o shellcode_exit -static shellcode_exit.c[scz@ /home/scz/src]&gt; gdb shellcode_exitGNU gdb 4.17.0.11 with Linux supportThis GDB was configured as "i386-redhat-linux"...(gdb) disas _exit &lt;-- -- -- 输入Dump of assembler code for function _exit:0x804b970 &lt;_exit&gt;: movl %ebx,%edx0x804b972 &lt;_exit+2&gt;: movl 0x4(%esp,1),%ebx0x804b976 &lt;_exit+6&gt;: movl $0x1,%eax0x804b97b &lt;_exit+11&gt;: int $0x800x804b97d &lt;_exit+13&gt;: movl %edx,%ebx0x804b97f &lt;_exit+15&gt;: cmpl $0xfffff001,%eax0x804b984 &lt;_exit+20&gt;: jae 0x804bc60 &lt;__syscall_error&gt;End of assembler dump. ​ 我们可以看到，exit系统调用将0x1放到EAX中(这是它的syscall索引值)，将退出码放入EBX中，然后执行”int$0x80”。大部分程序正常退出时返回0值，我们也在EBX中放入0。 ​ 现在我们所要完成的工作又增加了三项： ​ h) 将0x1拷贝到寄存器EAX中 i) 将0x0拷贝到寄存器EBX中 j) 执行中断指令int $0x80 ​ 同时，要注意不能出现0x00，要避免中途被截断。理清任务之后，可以很容易地用汇编语言写出shellcode： 1234567891011121314151617section .textglobal _start_start:xor eax,eaxpush eaxpush 0x68732f2f ；压入&quot;//sh&quot;push 0x6e69622f ；压入&quot;/bin&quot;mov ebx,esp ；将字符串的地址存入ebxpush eax ；压入&quot;0x00&quot;push ebx ；压入字符串&quot;/bin//sh&quot;的地址mov ecx,esp ；将指针数组地址存入ecxxor edx,edx ；[edx] = 0mov al,0xb ；将11写入eax，execve的系统调用号int 0x80mov al,0x1xor ebx,ebxint 0x80 ​ 根据之前int 0x80中断指令调用形式，要求eax存放系统调用号;ebx、ecx、edx分别存放参数部分。 ​ 汇编源码中，首先是第4行eax清零；之后第5行压栈；然后第6行，第7行字符串压栈，这样在栈中就构造了以”\x00”结尾的字符串”/bin//sh”。注意这里的“/bin//sh”与“/bin/sh”同样效果。此时的ESP指针指向了这个字符串首地址，第8行将该首地址赋给ebx，这样就有了int 0x80中断指令的第一个参数ebx；第9行中eax入栈，此时eax值还是0；第10行ebx入栈也就是把字符串”/bin//sh”地址入栈，两次压栈，此时栈中就有了字符串地址和一个0，刚好构成了一个指针数组；第11行将该指针数组的地址也就是esp赋给ecx，系统调用的第2个参数ecx中就保持了指针数组的地址；第12行edx清零，刚好是系统调用的第3个参数为零。第13行将系统调用号0xB赋给al,这样可以避免出现坏字符。最后调用软中断指令执行。 4、练习和示例*FreeBSD 堆栈 ；Linux 寄存器 1、编写如下c语言程序对应的shellcode： 1234int main() &#123; wirte(1, "hello, world\n",15); exit(0);&#125; ​ jmp/call方法，FreeBSD 1234567891011121314151617181920global _start_start:xor eax, eaxjmp short stringcode:pop esipush byte 15push esipush byte 1mov al,4push eaxint 0x80xor eax,eaxpush eaxpush eaxmov al,1int 0x80string:call codedb &quot;hello, world!&quot;, 0x0a 2、编写如下c语言程序对应的shellcode： 123int main() &#123; execve("/bin/sh",0,0);&#125; ​ push方法，FreeBSD 123456789101112BITS 32xor eax,eaxpush eaxpush 0x68732f6epush 0x69622f2fmov ebx,esppush eaxpush eaxpush ebxmov al,59push eaxint 80h 3、在Linux环境下分别用jmp/call方法和push方法各写一个汇编程序，完成如下c语言程序所要完成的功能，以便形成对应的shellcode。 123int main(void) &#123; execve("/bin/ksh",0,0);&#125; ​ push方法： 12345678910BITS 32xor eax,eaxxor edx,edxpush eaxpush &quot;/ksh&quot;push &quot;/bin&quot;mov ebx,espxor ecx,ecxmov al,0xbint 0x80 ​ jmp/call方法： 123456789101112BITS 32xor eax,eaxjmp short stringcode:pop ebxxor ecx,ecxxor edx,edxmov al,0xbint 0x80string:call codedb &quot;/bin/ksh&quot; 0x0 4、汇编语言直接编写shellcode(jmp/call方法，FreeBSD环境下）执行： 12345678int main() &#123; char *command="/bin/sh"; char *args[2]; args[0]=command; args[1]=0; execve(command,args,0);&#125;//第一个参数是字符串"/bin/sh"的地址 ​ jmp/call方法： 1234567891011121314151617181920global _start_start:xor eax, eaxjmp short stringcode:pop esipush eaxpush esipush esimov al,0xbpush eaxint 0x80xor eax,eaxpush eaxpush eaxmov al,1int 0x80string:call codedb &quot;/bin/sh&quot;, 0x0]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组中&a与&a[0]的区别]]></title>
    <url>%2F2018%2F04%2F08%2F%E6%95%B0%E7%BB%84%E4%B8%AD%26a%E4%B8%8E%26a%5B0%5D(%E5%8D%B3a)%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[数组中&amp;a与&amp;a[0](即a)的区别​ 在newcoder上写数组相关题目时遇到了这样一个问题： 12345//以下 C 语言指令：int a[5] = &#123;1,3,5,7,9&#125;;int *p = (int *)(&amp;a+1);printf(“%d,%d”,*(a+1) ， *(p-1));//运行结果是什么？ ​ 读者可以先自己思考一下这个问题~ 在这道题中，*(a+1)的输出结果是非常常规容易思考的，而*(int*)(&amp;a+1)的输出结果则需要一定的思考。 ​ 下面公布正确答案：3,9。 ​ 题目中首先定义了一个可以存在 ​ 题目中首先定义了存放5个int类型空间大小的内存，然后初始化5个数。我们知道直接使用数组的名字a表示的是一个指向数组首地址的指针，所以直接a与&amp;a[0]是相同的意思，都表示数组的首地址。所以(a+1)很好理解，假设a地址是0x1000，就是取（0x1000+sizeof(int)）地址的数，由于数组的物理地址是连续的，当然就是取2。 那&amp;a表示什么意思呢，相当于取存放指向数组首地址的指针的存储地址，话有些绕，但是细细品味你就会发现，它就相当于二维指针，假设每个一维指针指向一排数组（当然除了第一个一维数组的指针之外实际都没有申请，但是在访问野指针之前计算机也不知道那块地址是否存在，但的确可以由物理地址连续性来获取这块地址的表示），**所以简言之&amp;a表示第一排数组，&amp;a+1就是表示第二排数组（就是5\sizeof(int)=54=20空间大小后一段空间的首地址）。** 有了上面的介绍就好理解了，(ptr-1)是表示取(0x1000+5sizeof(int)-sizeof(int))地址中的数，算得为5。 总结： *&amp;a[0]表示数组的首地址，与直接a相同意义。而&amp;a表示存储指向数组首地址的指针的地址，可以用二维指针来理解。 *(int*)(&amp;a+1)]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newcoder 清华 最小邮票数]]></title>
    <url>%2F2018%2F04%2F01%2F%E6%9C%80%E5%B0%8F%E9%82%AE%E7%A5%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[清华复试上机 最小邮票数 题解题目描述：​ 有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。 输入描述:1有多组数据，对于每组数据，首先是要求凑成的邮票总值M，M&lt;100。然后是一个数N，N〈20，表示有N张邮票。接下来是N个正整数，分别表示这N张邮票的面值，且以升序排列。 输出描述:1对于每组数据，能够凑成总值M的最少邮票张数。若无解，输出0。 ​ 本题是一个01背包的变形，将每张邮票的价值看作1，要求在背包容量必须装满的情况下，价值达到最小。可以用动态规划来解决。 ​ 可以用一个二维数组dp[i][j]来表示在前i张里面填满空间j的最小邮票张数，则有dp[i][j] = min(dp[i -1][j] , dp[i - 1][j - ticket[i]] + 1) 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int M, N; int dp[101]; int ticket[21]; while(cin &gt;&gt; M &gt;&gt; N) &#123; for(int i = 0; i &lt; N; i++) cin &gt;&gt; ticket[i];//用数组ticket来存储第i张邮票的价值 for(int i = 0; i &lt; 101; i++) dp[i] = N + 1;//面值为i时需要的邮票数量,将其统一初始化为当前的最大值N+1 dp[0] = 0; dp[ticket[0]] = 1; for(int i = 1; i &lt;= N; i++) &#123;//i张邮票 for(int j = M; j &gt;= ticket[i]; j--) &#123; dp[j] = min(dp[j], dp[j - ticket[i]] + 1); &#125; &#125; if(dp[M] &lt;= N) cout &lt;&lt; dp[M] &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt;endl; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典习题2-5题解]]></title>
    <url>%2F2018%2F03%2F31%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E4%B9%A0%E9%A2%98%E9%A2%98%E8%A7%A3%20%2F</url>
    <content type="text"><![CDATA[算法竞赛入门经典习题2-5分数化小数(decimal)题目描述： ​ 输入正整数a, b, c, 输出a/b的小数形式，精确到小数点后c位。a,b &lt;= 10 ^ 6$, $c &lt;= 100。 输入包含多组数据，结束标记为a = b = c = 0。 ​ 因为这道题发现了printf的一种神奇的用法0.0。 1printf("%*.*lf\n", a, b, (double) c / d); ​ 其中，格式控制符%a.bf 表达的含义是：打印a位有效数字的b位小数。 %f是打印实数数据（float double类型的数据） a表示有效数字个数，b表示小数点后的位数。在本题中，只限制了小数点后的位数是c位，因此代码如下： 123456789101112#include&lt;stdio.h&gt;int main() &#123; int a, b, c; while(1) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); if(a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0) break; double ans = (double)a / b; printf("%.*f\n", c, ans); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[远程连接服务器的操作说明]]></title>
    <url>%2F2017%2F12%2F10%2F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[远程连接服务器的操作说明​ 在本科阶段的学习中，我们经常接触到服务器的概念。但很多同学都像我一样没有实际接触和操作过远程服务器。在真实的项目中，不知道如何操作自己远在千里之外的云端服务器。在本文中，笔者将以一个初学者的角度，详细地说明如何操作远程服务器、上传自己的资源、第一个网站的开发与发布过程。 一、有关服务器的简单操作1、 远程连接服务器​ 需要的知识储备：linux操作系统下常用的指令、linux文件系统的结构 ​ 需要的软件：仅列举本人实际使用过的putty和Xshell。（下文以putty的界面为例） ​ 在界面中输入下列信息: 主机名称：120.78.182.65 （这是本人测试开发用的服务器的外网ip，仅作示例。在这里填写自己要连接的远程服务器的ip地址即可） 端口号：22 退出时关闭系统：仅正常退出 然后点击打开，即看到如下界面： ​ 在login as: 提示后输入自己想要登陆的用户名（若输入root后，则以root身份登入服务器。）在界面提示输入密码时，输入自己设置好的密码。 ​ 敲击回车键，看到如下界面即为登入成功，可进行一系列操作。（此时的操作全部会同步到远程服务器端。） 2、 将本地的网站资源上传至服务器​ 下载一个文档上传用的软件，本文以FileZilla为例,完成安装后运行，看到如图所示界面。 点击菜单栏的“文件”选项，选择站点管理器，完成如下配置。 ​ 主机名和端口号与上文叙述的一致，协议选择SFTP。在用户名和密码栏填写自己想要在远程服务器端登陆的用户名和对应的密码。考虑到项目资源管理的独立性，一般来说，不建议以root用户登陆。 ​ 点击连接。看到如下界面即为连接成功。 ​ 本地站点的文件目录即为本地机器的文件目录，右侧即为服务器的文件目录，可通过更改远程站点栏的路径名，查看服务器各个文件目录下的资源。Apache2的默认网站路径为/var/www/html，将资源上传至这个目录下即可在浏览器得到显示。]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
